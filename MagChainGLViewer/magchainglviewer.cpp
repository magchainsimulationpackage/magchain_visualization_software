/*
 *  cgsviewer.cpp
 *  MagChainViewer application
 *  Author: Jordi Andreu Segura
 *  e-mail: jandreu@icmab.es
 *  Version: 24/11/2011 (beta)
 *  Last Modification: 16/11/2011
 *  Description: A simple visualization program designed to work with trajectory files generated by the MAGCHAIN application.
 *
 */

#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <cstdlib>
#include <time.h>
#include <math.h>
#include <iomanip>
#include <vector>
#include <string>
#include "element.h"

#ifdef __APPLE__
#include <GLUT/glut.h>
#else
#include <GL/glut.h>
#endif

using namespace std;

#define _PI 3.14159265
#define DEG2RAD 3.14159/180.0
#define TRANS_INC 5.0f
#define ROT_INC 5.0f

static enum {
    PERSPECTIVE, ORTHO
} mode = ORTHO;

static enum {
    TRANSLATE, ROTATE
} transformation = TRANSLATE;

static enum {
    CENTER, CORNER
} axis = CENTER;


GLfloat zoomf = 1.0f; // Zoom factor

GLfloat transX = 0.0f; // Translate screen to x direction (left or right)
GLfloat transY = 0.0f; // Translate screen to y direction (up or down)
GLfloat transZ = 0.0f; // Translate screen to z direction (zoom in or out)

GLfloat rotX = 0.0f; // Rotate screen on x axis 
GLfloat rotY = 0.0f; // Rotate screen on y axis
GLfloat rotZ = 0.0f; // Rotate screen on z axis
GLfloat rotLx = 0.0f; // Translate screen by using the glulookAt function (left or right)
GLfloat rotLy = 0.0f; // Translate screen by using the glulookAt function (up or down)
GLfloat rotLz = 0.0f; // Translate screen by using the glulookAt function (zoom in or out)

GLfloat xf = 1.0f;	// Scaling factors
GLfloat yf = 1.0f;
GLfloat zf = 1.0f;

GLfloat xbox = 1.0f;
GLfloat ybox = 1.0f;
GLfloat zbox = 1.0f;

GLint slices = 25;	// Resolution for rendered objects
GLint stacks = 25;

static GLfloat angle = 0;   // in degrees
static GLfloat angle2 = 0;   // in degrees

//mouse rotation control
static int moving = 0, startx, starty;

// animation
int ms0 = 1;
int ms = ms0;
unsigned int nframe = 0;
int play = -1;

vector <CFrame> frame;

GLUquadricObj *qobj ;
GLUquadricObj *qobj1 ;
GLUquadricObj *qobj2 ;
GLUquadricObj *qobj3 ;

int mainWindow;

GLfloat matbox_specular[] = {0.1, 0.1, 0.1, 0.1};
GLfloat matbox_ambient[] = {0.1, 0.1, 0.1, 0.1};
GLfloat matbox_diffuse[] = {0.1, 0.1, 0.1, 0.1};
GLfloat matbox_shininess[] = {128.0 * 0.4};

GLfloat mat_specular1[] = {0.628281, 0.555802, 0.366065, 1.0};
GLfloat mat_ambient1[] = {0.24725, 0.1995, 0.0745, 1.0};
GLfloat mat_diffuse1[] = {0.75164, 0.60648, 0.22648, 1.0};
GLfloat mat_shininess1[] = {128.0 * 0.4};

GLfloat mat_specular2[] = {0.508273, 0.508273, 0.508373};
GLfloat mat_ambient2[] = {0.19225, 0.19225, 0.19225};
GLfloat mat_diffuse2[] = {0.50754, 0.50754, 0.50754};
GLfloat mat_shininess2[] = {128.0 * 0.6};

GLfloat mat_specular3[] = {0.296648, 0.296648, 0.296648};
GLfloat mat_ambient3[] = {0.25, 0.20725, 0.20725};
GLfloat mat_diffuse3[] = {1, 0.829, 0.829};
GLfloat mat_shininess3[] = {128.0 * 0.088};

GLfloat mat_specular4[] = {0.633, 0.727811, 0.633};
GLfloat mat_ambient4[] = {0.0215, 0.1745, 0.0215};
GLfloat mat_diffuse4[] = {0.07568, 0.61424, 0.07568};
GLfloat mat_shininess4[] = {128 * 0.6};

GLfloat mat_specular5[] = {0.60, 0.60, 0.50};
GLfloat mat_ambient5[] = {0.0, 0.0, 0.0};
GLfloat mat_diffuse5[] = {0.5, 0.5, 0.0};
GLfloat mat_shininess5[] = {128.0 * 0.25};

void SetMaterial(GLfloat spec[], GLfloat amb[], GLfloat diff[], GLfloat shin[]){
    
	glMaterialfv(GL_FRONT, GL_SPECULAR, spec);
	glMaterialfv(GL_FRONT, GL_SHININESS, shin);
	glMaterialfv(GL_FRONT, GL_AMBIENT, amb);
	glMaterialfv(GL_FRONT, GL_DIFFUSE, diff);
    
}

static void motion(int x, int y){
    if (moving) {
        angle = angle + (x - startx);
        angle2 = angle2 + (y - starty);
        startx = x;
        starty = y;
        glutPostRedisplay();
    }
}

static void mouse(int button, int state, int x, int y){
    /* Rotate the scene with the left mouse button. */
    if (button == GLUT_LEFT_BUTTON) {
        if (state == GLUT_DOWN) {
            moving = 1;
            startx = x;
            starty = y;
        }
        if (state == GLUT_UP) {
            moving = 0;
        }
    }
}

void quit(){ cout << "exit." << endl; exit(0); }

void keyboard(unsigned char key, int x, int y){
    
    switch (key) {
        case 'P': mode = PERSPECTIVE; break;
        case 'O': mode = ORTHO; break;
        case 'T': transformation = TRANSLATE; break;
        case 'R': transformation = ROTATE; break;
        case 'a': axis = CENTER; break;
        case 'A': axis = CORNER; break;
        case 'x': if (transformation==ROTATE) { rotX -= ROT_INC; } else { transX += TRANS_INC; } break;
        case 'X': if (transformation==ROTATE) { rotX += ROT_INC; } else { transX -= TRANS_INC; } break;
        case 'y': if (transformation==ROTATE) { rotY += ROT_INC; } else { transY += TRANS_INC; } break;
        case 'Y': if (transformation==ROTATE) { rotY -= ROT_INC; } else { transY -= TRANS_INC; } break; 
        case 'z': if (transformation==ROTATE) { rotZ += ROT_INC; } else { transZ += TRANS_INC; } break;
        case 'Z': if (transformation==ROTATE) { rotZ -= ROT_INC; } else { transZ -= TRANS_INC; } break;
        case '+': zoomf -= 0.1f; break;
        case '-': zoomf += 0.1f; break; 
        case 'Q': quit(); break;
            
        case 'p':{
            
            if (play == 0) {play = -1; ms = 2000;} else if (play == -1) {play = 0; ms = ms0;} 
            
        }
            
            break;
            
        case 'r':{ nframe = 0; play=-1;}
            break;	
            
        case 'q': 
            
            transX = transY = transZ = 0.0f;
            zoomf = 1.0;
            rotX = 0.0f;
            rotY = 0.0f;
            rotZ = 0.0f;
            rotLx = 0.0f;
            rotLy = 0.0f;
            rotLz = 0.0f;
            angle = 0.0f;
            angle2 = 0.0f;
            break;
            
	}
    
	glutPostRedisplay();
    
}

void specialKeys (int key, int x, int y){
    
    switch (key) {
            
        case GLUT_KEY_LEFT :  angle -= ROT_INC;  break;
        case GLUT_KEY_RIGHT:  angle += ROT_INC;  break;
        case GLUT_KEY_UP   :  angle2 -= ROT_INC;  break;
        case GLUT_KEY_DOWN :  angle2 += ROT_INC;  break;
            
    }
    
    glutPostRedisplay();
}

void menu_select(int mode){
    
    switch (mode) {
            
        case 1:
            break;
            
        case 2:
            exit(EXIT_SUCCESS);
    }
    
}

void glutMenu(void){
    
	glutCreateMenu(menu_select);
	glutAddMenuEntry("Play/Pause [p]", 1);
	glutAddMenuEntry("Restart movie [r]", 1);
	glutAddMenuEntry("Perspective mode [P]", 1);
	glutAddMenuEntry("Orthographic mode [O]", 1);
	glutAddMenuEntry("Rotation mode [R]", 1);
    glutAddMenuEntry("Translation mode [T]", 1);
	glutAddMenuEntry("rotation or translation [x/X]", 1);
	glutAddMenuEntry("rotation or translation [y/Y]", 1);
	glutAddMenuEntry("rotation or translation [z/Z]", 1);		  
    
	glutAddMenuEntry("Axis at center [a]", 1);
	glutAddMenuEntry("Axis at corner [A]", 1);
    
	glutAddMenuEntry("Zoom IN [+]", 1);
  	glutAddMenuEntry("Zoom OUT [-]", 1);
	glutAddMenuEntry("Reset view [q]", 1);
    
	glutAddMenuEntry("Quit [Q]", 2);
	glutAttachMenu(GLUT_RIGHT_BUTTON);
    
}

void drawCylinder(float x, float y, float z, float length, float diameter){
    
	float radius = diameter/2.0;
	float factor = (1.0 - 0.05*(length/radius -1));
    
	glColor3f(factor, 0.7, 0.2);
    
	gluQuadricDrawStyle(qobj, GLU_FILL);
    
	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();
	glTranslatef(0.0, 0.0, -length/2.0);
	glTranslatef(x, y, z);	
    
	gluCylinder(qobj, radius, radius, length, slices, stacks);
    //	gluDisk(qobj, 0, radius, slices, stacks);
	gluSphere(qobj, radius, slices, stacks);
	glTranslatef(0.0, 0.0, length);
	gluSphere(qobj, radius, slices, stacks);
    //	gluDisk(qobj, 0, radius, slices, stacks);
	glPopMatrix();
}

void drawSphere(float x, float y, float z){
    
	glColor3f(0.5, 0.5, 0.5);
	gluQuadricDrawStyle(qobj, GLU_FILL);
	
	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();
	glTranslatef(x, y, z);	
	gluSphere(qobj, 0.5, slices, stacks);
	glPopMatrix();
}

void drawBox(GLfloat xsize, GLfloat ysize, GLfloat zsize){
    
	glMatrixMode(GL_MODELVIEW);
    
	SetMaterial(matbox_specular, matbox_ambient, matbox_diffuse, matbox_shininess);
    
    static GLfloat n[6][3] =
    {
        {-1.0, 0.0, 0.0},
        {0.0, 1.0, 0.0},
        {1.0, 0.0, 0.0},
        {0.0, -1.0, 0.0},
        {0.0, 0.0, 1.0},
        {0.0, 0.0, -1.0}
    };
    static GLint faces[6][4] =
    {
        {0, 1, 2, 3},
        {3, 2, 6, 7},
        {7, 6, 5, 4},
        {4, 5, 1, 0},
        {5, 6, 2, 1},
        {7, 4, 0, 3}
    };
    
	GLfloat v[8][3];
	GLint i;
    
    v[0][0] = v[1][0] = v[2][0] = v[3][0] = -xsize/2;
    v[4][0] = v[5][0] = v[6][0] = v[7][0] = xsize/2;
    v[0][1] = v[1][1] = v[4][1] = v[5][1] = -ysize/2;
    v[2][1] = v[3][1] = v[6][1] = v[7][1] = ysize/2;
    v[0][2] = v[3][2] = v[4][2] = v[7][2] = -zsize/2;
    v[1][2] = v[2][2] = v[5][2] = v[6][2] = zsize/2;
    
	glColor3f(0.9, 0.9, 0.9);
	
	glPushMatrix();
    
    for (i = 0; i < 6; i++) {
        glBegin(GL_LINE_LOOP);
        glNormal3fv(&n[i][0]);
        glVertex3fv(&v[faces[i][0]][0]);
        glVertex3fv(&v[faces[i][1]][0]);
        glVertex3fv(&v[faces[i][2]][0]);
        glVertex3fv(&v[faces[i][3]][0]);
        glEnd();
    }
	glPopMatrix();
    
}

void drawAxis(float x, float y, float z){
    
	double factor = (xbox + ybox + zbox)/3.0;
    
	float length = factor/15.0;
	float conlength = factor/30.0;
	float diam = factor/90.0;
	float condiam = factor/40.0;
    
	GLfloat ax = 0.0f;
	GLfloat ay = 0.0f;
	GLfloat az = 0.0f;
    
	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();
    
	if (axis == CORNER) {ax=-xbox/2.0f; ay=-ybox/2.0f; az=-zbox/2.0f;}
	if (axis == CENTER) {ax=0.0f; ay=0.0f; az=0.0f;}
    
	glTranslatef(ax, ay, az);
    
	// X AXIS RED
	glColor3f(1.0f, 0.0f, 0.0f);	//Red
	gluQuadricDrawStyle(qobj1, GLU_FILL);
	glRotatef(90,0,1,0);
	
	gluCylinder(qobj1, diam, diam, length, 2*slices, 2*stacks);
	glPushMatrix();
	glTranslatef(0, 0, length);	
	gluCylinder(qobj1, condiam, 0.0, conlength, 2*slices, 2*stacks);
	glPopMatrix();
    
	// Y AXIS GREEN
	glColor3f(0.0f, 1.0f, 0.0f);	//Green
	gluQuadricDrawStyle(qobj2, GLU_FILL);
	glRotatef(90,-1,0,0);
	gluCylinder(qobj2, diam, diam, length, 2*slices, 2*stacks);
	glPushMatrix();
	glTranslatef(0, 0, length);	
	gluCylinder(qobj2, condiam, 0.0, conlength, 2*slices, 2*stacks);
	glPopMatrix();
    
	// Z AXIS BLUE
	glColor3f(0.0f, 0.0f, 1.0f);	//Blue
	gluQuadricDrawStyle(qobj3, GLU_FILL);
	glRotatef(90,0,-1,0);
    
	gluCylinder(qobj3, diam, diam, length, 2*slices, 2*stacks);
	glPushMatrix();
	glTranslatef(0, 0, length);	
	gluCylinder(qobj3, condiam, 0.0, conlength, 2*slices, 2*stacks);
	glPopMatrix();
	glPopMatrix();	
    
}

void drawConfiguration(CFrame &f){
	
	for (unsigned int i=0; i<f.element.size(); i++){
        
        if (f.element[i].length == 1.0) {drawSphere(f.element[i].x, f.element[i].y, f.element[i].z);} else { drawCylinder(f.element[i].x, f.element[i].y, f.element[i].z, f.element[i].length, f.element[i].diameter);}	
        
	}	
    
}

void readData(int argc, char **argv){
    
	bool first = false;
	
	float oldxbox = 1.0;
	float oldybox = 1.0;
	float oldzbox = 1.0;
    
	ifstream infile;
    
	if (argc == 2){	infile.open(argv[1]); } else { cerr << "invalid file! Please, provide a valid trajectory file as argument." << endl; exit(0);}
	
	if (infile.is_open()){
        
		if (frame.size() != 0) {frame.clear();}
        
        string token;
        
        int k=0;
        int nelements;
        GLfloat xpos, ypos, zpos, length, diameter;
        
        cout << "loading frame(s)";
        
        while (!infile.eof() && getline(infile, token)){
            
            nelements = atoi(token.c_str()); //number of elements
            
            if (!first){
                
                getline(infile, token, ' ' ); xbox = atof(token.c_str());
                getline(infile, token, ' ' ); ybox = atof(token.c_str());	
                getline(infile, token); zbox = atof(token.c_str());
                
                if (xbox > zbox) { xf = 1.0; yf = ybox/xbox; zf = zbox/xbox; }
                else { xf = xbox/zbox; yf = ybox/zbox; zf = 1.0; }
                
                oldxbox = xbox;
                oldybox = ybox;
                oldzbox = zbox;
                
                xbox = 512*xf;
                ybox = 512*yf;
                zbox = 512*zf;
                
                first = true;
                
            } else { getline(infile, token); }
            
            
			double x0 = oldxbox/2.0;
			double y0 = oldybox/2.0;
			double z0 = oldzbox/2.0;
            
			CFrame faux(k);
            
			for (int i=0; i<nelements; i++){
                
				getline(infile, token, ' ' ); //get aggregate id (NOT USED)
				getline(infile, token, ' ' ); xpos = (atof(token.c_str()) - x0)*(xbox/oldxbox);
				getline(infile, token, ' ' ); ypos = (atof(token.c_str()) - y0)*(ybox/oldybox);
				getline(infile, token, ' ' ); zpos = (atof(token.c_str()) - z0)*(zbox/oldzbox);
				getline(infile, token, ' ' ); length = atof(token.c_str());
				getline(infile, token); diameter = atof(token.c_str());
				
				CElement aux(xpos, ypos, zpos, length, diameter);
				faux.element.push_back(aux);
                
			}
            
			frame.push_back(faux);
            cout << " " << k;
            
			k++;
            
		}
        
		cout << "\nfile " << argv[1] << " succesfully loaded!" << endl;
        
		infile.close();
	}
    
}

void makeFrustum(double fovY, double aspectRatio, double front, double back){
    
    double tangent = tan(fovY/2 * DEG2RAD);   // tangent of half fovY
    double height = front * tangent;          // half height of near plane
    double width = height * aspectRatio;      // half width of near plane
    
    // params: left, right, bottom, top, near, far
    glFrustum(-width, width, -height, height, front, back);
}

void animate(int value){
    
	if (play == 0){
        
		if (nframe < frame.size()-1) { nframe ++; }	
		else { play = -1; } 
        
	}
    
	glutTimerFunc(ms, animate, 1);
	glutPostRedisplay();
	
} 

void init(int argc, char **argv){
    
	cout << endl;
	cout << "************************************************" << endl;
	cout << "        MagChainViewer (beta) 24-Nov-2011 " << endl;
	cout << "************************************************" << endl;
	cout <<endl;
    
	glClearColor(0.0, 0.0, 0.0, 0.0);
    //	glShadeModel (GL_FLAT); // Low detail
	glShadeModel (GL_SMOOTH); // High detail
    
   	qobj = gluNewQuadric();//general
	qobj1 = gluNewQuadric();//axis
	qobj2 = gluNewQuadric();//axis
	qobj3 = gluNewQuadric();//axis
    
	readData(argc, argv);
    
    // Use depth buffering for hidden surface elimination.
	glEnable(GL_DEPTH_TEST);
    
	glEnable(GL_LIGHTING);	// Enables Lightning system
    
	GLfloat global_ambient[] = { 0.5f, 0.5f, 0.5f, 1.0f }; //Defines Global Ambient light. Default:{ 0.2f, 0.2f, 0.2f, 1.0f };
	glLightModelfv(GL_LIGHT_MODEL_AMBIENT, global_ambient);
    
    // Define poligons Normal direction
	glFrontFace(GL_CCW);
    
    // Define light SOURCES
	// LIGHT0 definition
	GLfloat position0[] =  {-2.0*xbox, -1.2*ybox, 0.8*zbox, 1.0};
	GLfloat specular0[] =  {0.5f, 0.5f, 0.5f, 1.0f};
	GLfloat ambient0[] = {0.2f, 0.2f, 0.2f, 1.0f};
	GLfloat diffuse0[] = {0.8f, 0.8f, 0.8f, 1.0f};
	glLightfv(GL_LIGHT0, GL_POSITION, position0);
	glLightfv(GL_LIGHT0, GL_SPECULAR, specular0);	
	glLightfv(GL_LIGHT0, GL_AMBIENT, ambient0);
	glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse0);
	glEnable(GL_LIGHT0);	// Enables LIGHT0
    
    // Enable color tracking
	glEnable(GL_COLOR_MATERIAL);
    
    // Define light MATERIALS	
	SetMaterial(mat_specular2, mat_ambient2, mat_diffuse2, mat_shininess2);
    
	glEnable (GL_LINE_SMOOTH);
	glHint(GL_LINE_SMOOTH_HINT, GL_NICEST); // Set Line Antialiasing
    
}

void display(void){ 
    
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glEnable(GL_DEPTH_TEST);
    
	glColor3f(1.0, 1.0, 1.0); 
	//clear the matrix
	glLoadIdentity();
	// viewing transformation 
	gluLookAt(0.0, 0.0, -zbox/2 + transZ, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0); 
	// modeling transformation
	glPushMatrix();	
	// Mouse and keys rotations
	glRotatef(rotX+angle2,1.0,0.0,0.0); // Rotate on x
    glRotatef(rotY,0.0,0.0,1.0); // Rotate on y
	glRotatef(-90,1.0,0.0,0.0);
	glRotatef(180,0.0,0.0,1.0);
    glRotatef(rotZ+angle,0.0,0.0,1.0); // Rotate on z
    
	glTranslatef(transX,transY,transZ);
    
	if (frame.size() !=0) {	drawBox(xbox, ybox, zbox); drawAxis(0.0f, 0.0f, 0.0f); drawConfiguration(frame[nframe]);}
    
	glPopMatrix();
    
	glMatrixMode(GL_PROJECTION); 
	glLoadIdentity(); 
    
	if (mode == PERSPECTIVE){
		makeFrustum(zoomf*xbox, 1, 1, 2.0*zbox);}
    else if (mode == ORTHO){
		glOrtho (zoomf*(-1.3*xbox/2.0), zoomf*(1.3*xbox/2.0),  zoomf*(-1.3*ybox/2.0), zoomf*(1.3*ybox/2.0), zoomf*(-1.3*zbox/2.0), zoomf*(1.3*zbox/2.0));
	}
    
	glMatrixMode(GL_MODELVIEW);
    
	glFlush();
    glutSwapBuffers();
    
}

void reshape(int w, int h){ 
    
    glViewport(0, 0, (GLsizei) h*(xf/yf), (GLsizei) h);
    
} 

int main(int argc, char **argv){
    
	// start of glut windowing and control functions
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA | GLUT_DEPTH);
	glutInitWindowSize(512, 512);
	mainWindow = glutCreateWindow("MagChainGLViewer 24Nov2011 (beta)");
	init(argc, argv);
    
	// program control to GLUT
    glutDisplayFunc(display);
    glutReshapeFunc(reshape);
	glutTimerFunc(ms, animate, 1);
	glutKeyboardFunc(keyboard);
	glutSpecialFunc(specialKeys);
	glutMouseFunc(mouse);
	glutMotionFunc(motion);
    glutMenu();
    
    glutMainLoop(); 
    return 0;
}
